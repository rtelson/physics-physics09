<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Pierre Marie Curie – Physics 9 – Prof. Telson</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; text-align: center; }
    h1 { margin-bottom: 4px; }
    h2 { color: #555; margin-top: 0; }
    #controls {
      display: inline-flex;
      gap: 20px;
      margin-bottom: 4px;
      align-items: center;
    }
    #message {
      font-size: 0.9em;
      color: #333;
      font-style: italic;
      margin-bottom: 20px;
    }
    #charts {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin-top: 20px;
    }
    .chart-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .chart-wrapper h3 { margin-bottom: 8px; }
    svg { border: 1px solid #ccc; background: #fafafa; }
    .line { fill: none; stroke-width: 2px; }
    .dial { cursor: ns-resize; }
    .dial.acc  { fill: red; }
    .dial.vel  { fill: green; }
    .dial.init { fill: blue; } /* only for x₀ dial */
    .grid line { stroke: #ddd; }
    .grid path { display: none; }
    .axis path, .axis line { stroke: #333; }
    .axis text { font-size: 12px; }
  </style>
</head>
<body>

  <h1>Pierre Marie Curie – Physics 9 – Prof. Telson</h1>
  <h2>Kinematics Simulator</h2>

  <div id="controls">
    <label>
      <input type="radio" name="mode" value="acc" checked>
      Acceleration-driven
    </label>
    <label>
      <input type="radio" name="mode" value="vel">
      Velocity-driven
    </label>
    <label>
      Δt (s)
      <input type="number" id="dt" value="1.0" min="0.01" step="0.01">
    </label>
    <button id="exportBtn">Export CSV</button>
  </div>

  <div id="message"></div>

  <div id="charts">
    <div class="chart-wrapper">
      <h3>Position vs. Time</h3>
      <div id="pos-chart"></div>
    </div>
    <div class="chart-wrapper">
      <h3>Velocity vs. Time</h3>
      <div id="vel-chart"></div>
    </div>
    <div class="chart-wrapper">
      <h3>Acceleration vs. Time</h3>
      <div id="acc-chart"></div>
    </div>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    // Helper to clamp values
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

    // Detect platform for export message
    const messageDiv = d3.select('#message');
    let msg = '';
    if ('showSaveFilePicker' in window) {
      msg = 'A save‐as dialog will open—choose where to save your CSV file.';
    } else if (/iphone|ipad|ipod/i.test(navigator.userAgent)) {
      msg = 'The CSV will be saved in your Files app (Downloads folder).';
    } else {
      msg = 'The CSV will download to your default browser download location.';
    }
    messageDiv.text(msg);

    // 1) Configuration
    const duration = 5;
    const margin   = { top: 30, right: 30, bottom: 45, left: 60 };
    const OW       = 450, OH = 375;   // 1.5× base size
    const W        = OW - margin.left - margin.right;
    const H        = OH - margin.top  - margin.bottom;

    // DOM refs
    const dtInput   = d3.select('#dt');
    const modeInput = d3.selectAll('input[name=mode]');
    const exportBtn = d3.select('#exportBtn');

    // Build SVG containers
    function makeSVG(sel) {
      return d3.select(sel)
        .append('svg').attr('width',OW).attr('height',OH)
        .append('g').attr('transform',`translate(${margin.left},${margin.top})`);
    }
    const svgPos = makeSVG('#pos-chart');
    const svgVel = makeSVG('#vel-chart');
    const svgAcc = makeSVG('#acc-chart');

    // Scales
    const xScale  = d3.scaleLinear([0,duration],[0,W]);
    const yScaleP = d3.scaleLinear([-10,10],[H,0]);
    const yScaleV = d3.scaleLinear([-10,10],[H,0]);
    const yScaleA = d3.scaleLinear([-10,10],[H,0]);

    // Line generators
    const lineP = d3.line().curve(d3.curveBasis)
      .x(d=>xScale(d.t)).y(d=>yScaleP(d.x));
    const lineV = d3.line()
      .x(d=>xScale(d.t)).y(d=>yScaleV(d.v));
    const lineA = d3.line()
      .x(d=>xScale(d.t)).y(d=>yScaleA(d.a));

    // Axes + grid setup
    function setupAxes(svg, yLabel) {
      svg.append('g').attr('class','grid x-grid')
         .attr('transform',`translate(0,${H})`);
      svg.append('g').attr('class','grid y-grid');
      svg.append('g').attr('class','axis x-axis')
         .attr('transform',`translate(0,${H})`);
      svg.append('g').attr('class','axis y-axis')
        .append('text')
          .attr('transform','rotate(-90)')
          .attr('y',12).attr('dy','-3.5em')
          .attr('text-anchor','end')
          .text(yLabel);
    }
    setupAxes(svgPos,'Position (m)');
    setupAxes(svgVel,'Velocity (m/s)');
    setupAxes(svgAcc,'Acceleration (m/s²)');

    // Path elements
    const pathP = svgPos.append('path').attr('class','line').attr('stroke','blue');
    const pathV = svgVel.append('path').attr('class','line').attr('stroke','green');
    const pathA = svgAcc.append('path').attr('class','line').attr('stroke','red');

    // Dial‐drag helper
    function dialDrag(yScale, setter) {
      return d3.drag().on('drag',(ev,d)=>{
        const y   = clamp(ev.y,0,H);
        const val = yScale.invert(y);
        setter(d,clamp(val,yScale.domain()[0],yScale.domain()[1]));
        d3.select(ev.sourceEvent.target).attr('cy',yScale(d[Object.keys(d)[1]]));
        updateAll();
      });
    }

    // Time grid and data arrays
    let tPoints = [], accData = [], velData = [];

    function buildTimePoints(dt) {
      return d3.range(0, duration+1e-9, dt).map(t=>+t.toFixed(6));
    }
    function buildAccData(dt) {
      return tPoints.map(t=>({
        t,
        a: clamp(6*t - 6, -10, 10)
      }));
    }
    function buildVelDataFromAcc(dt) {
      const aPts = accData.map(d=>d.a);
      const vPts = [velData[0]?.v||0];
      for (let i=1; i<aPts.length; i++) {
        vPts.push(vPts[i-1] + aPts[i-1]*dt);
      }
      return tPoints.map((t,i)=>({t, v:vPts[i]}));
    }

    // Rebuild dials on Δt change
    let accSel, velSel;
    function rebuildDials() {
      const dt = +dtInput.node().value;
      tPoints = buildTimePoints(dt);
      accData = buildAccData(dt);

      if (modeInput.filter(':checked').node().value === 'vel') {
        velData = buildVelDataFromAcc(dt);
      } else {
        velData = velData.slice(0,1).concat(
          tPoints.slice(1).map((t,i)=>({t, v: velData[i+1]?.v||0}))
        );
      }

      // Acceleration dials
      accSel = svgAcc.selectAll('circle.dial.acc')
        .data(accData, d=>d.t);
      accSel.exit().remove();
      accSel = accSel.enter()
        .append('circle').attr('class','dial acc').attr('r',6)
        .merge(accSel)
          .attr('cx',d=>xScale(d.t))
          .attr('cy',d=>yScaleA(d.a))
          .call(dialDrag(yScaleA,(d,v)=>d.a=clamp(v,-10,10)));

      // Velocity dials
      velSel = svgVel.selectAll('circle.dial.vel')
        .data(velData, d=>d.t);
      velSel.exit().remove();
      velSel = velSel.enter()
        .append('circle').attr('class','dial vel').attr('r',6)
        .merge(velSel)
          .attr('cx',d=>xScale(d.t))
          .attr('cy',d=>yScaleV(d.v))
          .call(dialDrag(yScaleV,(d,v)=>d.v=clamp(v,-10,10)));
    }

    // Initial position dial at t=0
    let x0 = 0;
    const posDial = svgPos.append('circle')
      .attr('class','dial init').attr('r',6)
      .attr('cx',xScale(0)).attr('cy',yScaleP(x0))
      .call(dialDrag(yScaleP, (_,v)=>x0=clamp(v,-10,10)));

    // Main update function
    let lastData = [];
    function updateAll() {
      const mode = modeInput.filter(':checked').node().value;
      const dt   = +dtInput.node().value;

      if (!tPoints.length || Math.abs((tPoints[1]-tPoints[0])-dt) > 1e-9) {
        rebuildDials();
      }

      let aSamp = accData.map(d=>d.a),
          vSamp = [], xSamp = [];

      if (mode === 'acc') {
        vSamp = [velData[0]?.v||0];
        for (let i=1; i<aSamp.length; i++) {
          vSamp.push(vSamp[i-1] + aSamp[i-1]*dt);
        }
      } else {
        vSamp = velData.map(d=>d.v);
        aSamp = [];
        for (let i=0; i<vSamp.length-1; i++) {
          aSamp.push((vSamp[i+1]-vSamp[i]) / dt);
        }
        aSamp.push(aSamp[aSamp.length-1]);
      }

      xSamp = [x0];
      for (let i=1; i<vSamp.length; i++) {
        xSamp.push(
          xSamp[i-1]
          + vSamp[i-1]*dt
          + 0.5*aSamp[i-1]*dt*dt
        );
      }

      lastData = tPoints.map((t,i)=>({
        t, x:xSamp[i], v:vSamp[i], a:aSamp[i]
      }));

      const xGrid  = d3.axisBottom(xScale).tickValues(tPoints).tickSize(-H).tickFormat('');
      const yGridP = d3.axisLeft(yScaleP).ticks(8).tickSize(-W).tickFormat('');
      const yGridV = d3.axisLeft(yScaleV).ticks(8).tickSize(-W).tickFormat('');
      const yGridA = d3.axisLeft(yScaleA).ticks(9).tickSize(-W).tickFormat('');

      svgPos.select('.x-grid').call(xGrid);
      svgPos.select('.y-grid').call(yGridP);
      svgVel.select('.x-grid').call(xGrid);
      svgVel.select('.y-grid').call(yGridV);
      svgAcc.select('.x-grid').call(xGrid);
      svgAcc.select('.y-grid').call(yGridA);

      const xAxis = d3.axisBottom(xScale).tickValues(tPoints).tickFormat(d=>d.toFixed(2));
      svgPos.select('.x-axis').call(xAxis);
      svgVel.select('.x-axis').call(xAxis);
      svgAcc.select('.x-axis').call(xAxis);

      svgPos.select('.y-axis').call(d3.axisLeft(yScaleP).ticks(8));
      svgVel.select('.y-axis').call(d3.axisLeft(yScaleV).ticks(8));
      svgAcc.select('.y-axis').call(d3.axisLeft(yScaleA).ticks(9));

      pathP.datum(lastData).attr('d', lineP);
      pathV.datum(lastData).attr('d', lineV);
      pathA.datum(lastData).attr('d', lineA);

      posDial.attr('cy', yScaleP(x0));
      accSel.attr('cy', d=>yScaleA(d.a));
      velSel.attr('cy', d=>yScaleV(d.v));

      accSel.style('display', mode==='acc' ? null : 'none');
      velSel.style('display', mode==='vel' ? null : 'none');
    }

    // CSV export with save dialog support
    async function exportCSV() {
      const header = 't,x,v,a\n';
      const rows   = lastData.map(d=>`${d.t},${d.x},${d.v},${d.a}`).join('\n');
      const blob   = new Blob([header+rows], { type:'text/csv' });

      if ('showSaveFilePicker' in window) {
        const handle = await window.showSaveFilePicker({
          suggestedName: 'kinematics.csv',
          types: [{ description:'CSV', accept:{'text/csv':['.csv']} }]
        });
        const writable = await handle.createWritable();
        await writable.write(blob);
        await writable.close();
      } else {
        const url = URL.createObjectURL(blob);
        const a   = document.createElement('a');
        a.href    = url;
        a.download= 'kinematics.csv';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
    }

    // Wire events
    dtInput .on('input',  updateAll);
    modeInput.on('change',updateAll);
    exportBtn.on('click', exportCSV);

    // Initial draw
    updateAll();
  });
  </script>
</body>
</html>
